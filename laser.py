#!/usr/bin/env python

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import numpy as np
import rospy

from geometry_msgs.msg import Point
# Laser scan message:
# http://docs.ros.org/api/sensor_msgs/html/msg/LaserScan.html
from sensor_msgs.msg import LaserScan
# For visualising the centroid.
from visualization_msgs.msg import Marker
# For pose information.
from tf.transformations import euler_from_quaternion
# For clustering the points
from sklearn.cluster import DBSCAN
# For colouring clusters
from std_msgs.msg import ColorRGBA
# For getting distances between centroids
from sklearn.metrics.pairwise import euclidean_distances

CLUSTER_COLOURS = [
    ColorRGBA(140.0, 224.0, 255.0, 1.0),
    ColorRGBA(12.0, 227.0, 208.0, 1.0),
    ColorRGBA(252.0, 255.0, 89.0, 1.0),
    ColorRGBA(127.0, 31.0, 127.0, 1.0),
    ColorRGBA(232.0, 163.0, 74.0, 1.0)]


class Laser(object):
    def __init__(self, name, min_angle, max_angle, max_distance):
        rospy.Subscriber('/' + name + '/scan', LaserScan, self.callback)
        # For publishing the clusters
        self.clusters_publishers = [
            rospy.Publisher('/' + name + '/cluster0', Marker, queue_size=5),
            rospy.Publisher('/' + name + '/cluster1', Marker, queue_size=5),
            rospy.Publisher('/' + name + '/cluster2', Marker, queue_size=5),
            rospy.Publisher('/' + name + '/cluster3', Marker, queue_size=5),
            rospy.Publisher('/' + name + '/cluster4', Marker, queue_size=5)]
        # For publishing the centroid
        self.centroid_publisher = rospy.Publisher('/' + name + '/centroid', Marker, queue_size=1)

        # Name of the robot to which the laser belongs
        self._name = name

        # Take measurements between min_angle and max_angle at distances less than max_distance
        self._min_angle = min_angle
        self._max_angle = max_angle
        self._max_distance = max_distance

        # Distance measurements and angles at which they were measured
        # i.e. (measurements[0], angles[0]), (measurements[1], angles[1]), ...
        self._angles = []
        self._measurements = []

        # PointCloud of the laser measurements between min_angle and max_angle
        # point_cloud[i] is a point [x, y, z]
        self._point_cloud = []

        # Clusters of points generated by the laser measurements
        self._clusters = []

    def callback(self, msg):
        # Helper for angles.
        def _within(x, a, b):
            pi2 = np.pi * 2.
            x %= pi2
            a %= pi2
            b %= pi2
            if a < b:
                return a <= x and x <= b
            return a <= x or x <= b

        # At each callback, take all distances measured between _min_angle and
        # _max_angle that are less than _max_distance
        self._measurements = []
        self._angles = []
        for i, d in enumerate(msg.ranges):
            # Angle at which the distance d was measured
            angle = msg.angle_min + i * msg.angle_increment
            if not np.isnan(d) and not np.isinf(d) and _within(angle, self._min_angle, self._max_angle) and d < self._max_distance:
                self._angles.append(angle)
                self._measurements.append(d)
        
        # Generate PointCloud of the laser measurements between _min_angle and _max_angle
        # that are less than _max_distance. Points are relative to the robot (base_link)
        points = []
        for i, d in enumerate(self._measurements):
            point = [
                d * np.cos(self._angles[i] % (2 * np.pi)),
                d * np.sin(self._angles[i] % (2 * np.pi)),
                0.]
            if (not point == [0., 0., 0.]):
                points.append(point)
        self._point_cloud = np.array(points, dtype=np.float32)
        point_cloud = self._point_cloud

        self._clusters = []
        if len(point_cloud) != 0:
            # DBSCAN clustering
            model = DBSCAN(eps=0.2, min_samples=2)
            labels = model.fit_predict(point_cloud)
            clusters = []
            for i in range(0, np.max(labels) + 1):
                clusters.append(point_cloud[np.nonzero(labels == i)])
            self._clusters = np.array(clusters)

    @property
    def ready(self):
        return len(self._measurements) == 0 or not np.isnan(self._measurements[0])

    @property
    def measurements(self):
        return self._measurements
    
    @property
    def angles(self):
        return self._angles

    @property
    def point_cloud(self):
        return self._point_cloud

    @property
    def get_clusters(self):
        return self._clusters
    
    @property
    # Returns the centroids of all clusters relative to the robot (base link)
    def get_centroids(self):
        clusters = self._clusters

        # Publish clusters using markers
        for i in range(0, len(clusters)):
            cluster = clusters[i]
            pc = Marker()
            pc.header.frame_id = '/' + self._name + '/base_link'
            pc.type = pc.POINTS
            pc.action = pc.ADD
            pc.pose.orientation.w = 1
            pc.points = []
            for point in cluster:
                pc.points.append(Point(point[0], point[1], point[2]))
            t = rospy.Duration()
            pc.lifetime = t
            pc.scale.x = 0.05
            pc.scale.y = 0.05
            pc.color = CLUSTER_COLOURS[i]
            self.clusters_publishers[i].publish(pc)
        
        if len(clusters) == 0:
            # No clusters, so return no centroid
            return np.array([], dtype=np.float32)
        
        # Get centroids of all clusters
        centroids = np.array([np.mean(cluster, axis=0)[:-1] for cluster in clusters], dtype=np.float32)

        print("Centroids for " + self._name + " in get_centroids:")
        print(centroids)

        return centroids